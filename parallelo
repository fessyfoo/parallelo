#!/usr/bin/perl

# copyright 2010 john "fess" fessenden
# Released under the Gnu Public License

## yet another parallelizer
## this one in perl and not specific to ssh. in the hopes of being portable and useful

# TODO: handle command  output in an organized fashion.   save to file.  or prefixed with hostname
# TODO: host range expansion

use strict;
use IO::Handle;
use IO::Select;
use IPC::Open3;

use Getopt::Long qw(
  :config
  require_order
  pass_through
  no_ignore_case
);

my $run_count = 0;
my $max_paralllel = 20;
my %hosts;

sub reap_child 
  {
    my $pid = wait ();
    my $ret = $?;
    return $pid if $pid == -1;
    print $hosts{$pid}, ": "; 
    if ($ret & 127) 
      {
        print "died on signal ", ($ret & 127);
      }
    else 
      {
        print "exited ", $ret >> 8;
      }
    print "\n";
  }
#$SIG{CHLD} = sub {};

sub run_cmd { 
  my $host = shift;
  my $in   = new IO::Handle ();
  my $out  = new IO::Handle ();
  my $err  = new IO::Handle ();

  my $pid = open3($in, $out, $err, @_);

  # failed fork
  die "fork failed; $!" if ! defined $pid;

  # parent
  if ($pid) {
    return { 
      pid    => $pid,
      stderr => $err,
      stdout => $out,
      stdin  => $in,
      host   => $host
    }
  }
  die "unexpected return from open3";
}

my @hostfiles;
my @hosts;
my $user = $ENV{'USER'};


GetOptions 
  ( 
    "H|hostfile=s"  => \@hostfiles,
    "h|host=s"      => \@hosts,
    "l|user=s"      => \$user,
    "max-parallel=i" => \$max_paralllel,
  ) || die "bad args\n";

for my $hostfile (@hostfiles)
  {
    open (FH, $hostfile) || die "failed to open $hostfile: $!\n";
    while (<FH>) 
      { 
        next if /^#/;
	s/#.*//;
	s/\s.*//g;
	push (@hosts, $_);
      }
  }

my $select = new IO::Select ();
my $running;
my %err_to_cmd;
my %out_to_cmd;
while (@hosts || $running) {
  while (@hosts && $running <= $max_paralllel) {
    my $host = shift @hosts;
    my @args = @ARGV;
    my @args = map {
      s/__HOST__/$host/g;
      s/__USER__/$user/g;
      $_;
    } @args;
    print "host: $host\n";
    my $cmd = run_cmd ($host, @args);
    $running++;
    my $cmd_stdout = fileno($cmd->{'stdout'});
    my $cmd_stderr = fileno($cmd->{'stderr'});
    print "$cmd_stderr\n";
    print "$cmd_stdout\n";
    $select->add ($cmd_stdout);
    $select->add ($cmd_stderr);
    $err_to_cmd {$cmd_stderr} = $cmd; 
    $out_to_cmd {$cmd_stdout} = $cmd; 
  }

  $SIG{'CHLD'} = 'IGNORE';
  my @ready = $select->can_read ();
  for my $fd (@ready) {
    my $data;
    my $cmd;
    my $fd_type;
    if (defined $err_to_cmd{$fd}) {
      $cmd  = $err_to_cmd{$fd};
    } elsif (defined $out_to_cmd{$fd}) {
      $cmd  = $out_to_cmd{$fd};
      $fd_type='stdout';
    }
    my $ct = sysread ($fd, $data, 8096);
    if ($ct != 0) {
      printf "%s (%s): %s\n", $cmd->{'host'}, $fd_type, $_ for split (/\n/, $data);
      $data = "";
    } else {
      $select->remove ($fd);
      $running --;
      waitpid ($cmd->{'pid'}, 0);
      # todo handle exit code
    }
  }
}
